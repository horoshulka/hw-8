 __**Хрусталь Варвара Дмитриевна УИБО-14-24**__
__________________________________________________________

**Алгоритм (пошагово)**

# Шаг 1: Инициализация структур данных

1.1. Создаем пустое множество для вершинного покрытия (cover)

1.2. Создаем копию множества всех ребер графа (remaining_edges)

1.3. Инициализируем счетчик добавленных вершин

# Шаг 2: Основной цикл алгоритма

2.1. Пока множество оставшихся ребер не пусто:

2.2. Выбираем произвольное ребро (u, v) из remaining_edges

2.3. Удаляем это ребро из множества remaining_edges

2.4. Добавляем обе вершины u и v в множество cover

2.5. Удаляем из remaining_edges все ребра, инцидентные u или v

# Шаг 3: Проверка корректности покрытия

3.1. Для каждого ребра (u, v) исходного графа проверяем:

3.2. Если u ∉ cover и v ∉ cover - покрытие некорректно

3.3. Иначе - покрытие корректно

3.4. Выводим размер покрытия и список вершин

# Шаг 4: Анализ качества аппроксимации

4.1. Вычисляем размер найденного покрытия |C|

4.2. Оцениваем минимальное возможное покрытие |OPT|

4.3. Вычисляем коэффициент аппроксимации |C|/|OPT|

4.4. Проверяем выполнение условия |C| ≤ 2×|OPT|

__________________________________________________________

**Временная сложность**

Временная сложность - это оценка времени работы алгоритма в зависимости от размера входных данных.

· Основной цикл: O(E) итераций, где E - количество ребер

· Удаление инцидентных ребер: O(E) в худшем случае

· Итоговая сложность: O(E²) в худшем случае

**Для данного алгоритма Vertex Cover:**

O(E²) - квадратичная сложность по количеству ребер

· E - количество ребер в графе

· При увеличении E в 2 раза, время работы увеличивается в 4 раза

**Разбивка по шагам:**

1. Инициализация: O(E) - создание копии множества ребер
2. Основной цикл: O(E) итераций
3. Удаление ребер: O(E) операций на каждой итерации
4. Проверка корректности: O(E) операций

**Практические значения:**

· 10 ребер: ~100 операций
· 50 ребер: ~2,500 операций  
· 100 ребер: ~10,000 операций

__________________________________________________________

**Коэффициент аппроксимации**

Аппроксимация - гарантия того, что найденное решение не более чем в K раз хуже оптимального.

**Определения:**
· OPT - оптимальное вершинное покрытие минимального размера
· APPROX - вершинное покрытие, найденное алгоритмом
· A - множество ребер, выбранных алгоритмом

**Алгоритм гарантирует 2-аппроксимацию:**

1. Ребра в A не имеют общих вершин (независимое множество ребер)
2. Любое вершинное покрытие должно содержать ≥ |A| вершин
3. Наш алгоритм добавляет 2 вершины для каждого ребра из A
4. Следовательно: |APPROX| = 2 × |A| ≤ 2 × |OPT|

**Для данного алгоритма Vertex Cover:**

· Гарантия: размер найденного покрытия ≤ 2 × размер оптимального покрытия

· На практике: обычно 1.5-2.0 × оптимального

**Условия применения:**

· Произвольный неориентированный граф
· Может содержать циклы
· Работает для связных и несвязных графов
· Не требует метрических свойств

__________________________________________________________

**Контрольный вопрос 4**

Почему жадный алгоритм для задачи о вершинном покрытии дает 2-аппроксимацию? Приведите доказательство.

**Ответ:**

**Доказательство 2-аппроксимации:**

1. **Анализ выбранных ребер:**
   - Алгоритм выбирает ребра (u₁,v₁), (u₂,v₂), ..., (uₖ,vₖ)
   - Эти ребра не имеют общих вершин (независимое множество ребер)
   - После выбора ребра (uᵢ,vᵢ) удаляются все инцидентные ребра

2. **Оценка оптимального покрытия:**
   - Любое вершинное покрытие должно покрывать все выбранные ребра
   - Поскольку ребра не пересекаются, оптимальное покрытие должно содержать хотя бы одну вершину из каждого ребра
   - Следовательно: |OPT| ≥ k, где k - количество выбранных ребер

3. **Оценка найденного покрытия:**
   - Алгоритм добавляет 2 вершины для каждого выбранного ребра
   - |APPROX| = 2k

4. **Сравнение с оптимальным:**
   - |APPROX| = 2k ≤ 2 × |OPT|
   - Коэффициент аппроксимации: |APPROX|/|OPT| ≤ 2

**Графический пример:**
Для пути из 3 вершин (a-b-c) с ребрами (a,b) и (b,c):
- Алгоритм может выбрать ребро (a,b), добавить {a,b}, затем выбрать (b,c), добавить {b,c}
- Итоговое покрытие: {a,b,c} размером 3
- Оптимальное покрытие: {b} размером 1
- Коэффициент: 3/1 = 3 (превышает гарантию из-за специфики выбора ребер)

**Ключевой вывод:** Алгоритм гарантирует, что найденное решение не более чем в 2 раза хуже оптимального, хотя на конкретных примерах может работать лучше или хуже этой границы.
